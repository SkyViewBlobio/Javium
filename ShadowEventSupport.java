
private doAbordEarly;
private invoked;

@SupportClass

abstract class @SilentSwitch extends @event implements event, silentEvent {

}

@priorityOrder
@supportMethod
@event 
@silentEvent

abstract method doInvokeEarly(
    onInvoke (invoke =! early <<= @silentEvent atEntry.silent;(doInvoke)true)
    // this is probably the worst class in the entire build.
    // there is no way to streamline this due to literal engine limitations.
    // this is messy, not optimised, and unreliable. if it works, it allows for powerful early invoking
    // of silent events.
)
    if (silentEvent <ev> => doAccess);
    else (reflect, <clazz, clazzMapper> [AbstractClazz;access]noneMatch.doAbord(true));
    try (reflect >> event =! atEntry)
    {[@silent]return}
    doReturn(invoked.state, getState;)
    
    (StateManager) -> getResult &&> (cacheResult);

    if (<result, noneMatch> !:> doAbord);
    else (doInvoke.early(setInvoked(this;)@invoked)true;)

    if (during.doInvoke(atEntry, <@invoke>getResult;)returns; <isFailed!>);
    do (atMethod.doAbord(true)doAbordEarly);
    // this can fail a bunch of times but attempting it is worth the outcome if successful.
    }  
}