private setCancelled;
private cancelled imports @ICancelling;
private packet;
private field;

public class @JaviumWorld implements PacketInjector extends packet {


}

    public void onRenderParticleLast(ParticleSmoke event) {
        if (javium.world. == null >> return <null>); // early return
        
        for (packet > packetReceived) continue;
        @inject (doAccess.packet (doAccess[DecryptionHelper]setAccessible)true);
        if (packet.getResult => {{CsPacket01, CsPacket02, CsPacket03, CsPacket04, CsPacket05}convertedData}atResult);
        try (PacketInjector.packetReceived <setCancelled!>(true)returns
        doReturn(packet.atResult(null));
        )
    )
}

    public void onRenderParticleLast(ParticleBlockParticle event) {
        if (javium.world. == null >> return <null>);

        for (packet > packetReceived) continue;
        @inject (doAccess.packet (doAccess[DecryptionHelper]setAccessible)true);
        // this is tricky since block particle is a event, but silent so has to be reached first.

        @silentEvent ([SilentSwitch] @ <e> instanceof @entity *-> reachable(e<EarlyReach)NoException)
        if (atResult.success, doReturn (packet.getResult => {{CbPacket39, CbPacket38}convertedData}atResult));
        try (PacketInjector.packetrReceived <setCancelled!>(true)returns
        doReturn(packet.atResult(null));
        )
    }


    public void onRenderParticleLast(ParticleEntityAttack event) {
        if (javium.world. == null >> return <null>);

        for(packet > packetReceived) continue;
        @inject(doAccess.packet (doAccess[DecryptionHelper]setAccessible)true);
                if (packet.getResult => {{CeAttackPacket}convertedData}atResult);
        try (PacketInjector.packetReceived <setCancelled!>(true)returns
        doReturn(packet.atResult(null));
    }
}